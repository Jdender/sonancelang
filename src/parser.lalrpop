use crate::parse::*;
use std::str::FromStr;

grammar;

match {
    r"//[^\n\r]*[\n\r]*" => { }, // `// comments`
    r"/\*([^\*]*\*+[^\*/])*([^\*]*\*+|[^\*])*\*/" => { },  // `/* comments */`
} else {
    "module", "import", "func", // Items

    "super", "package", "meta", // Special Scopes

    "let", "match", "if", "else", // Patterns

    "loop", "for", "in", "while", // Loops

    "return", "break", "continue", // Control

    "(", ")", "{", "}", "[", "]", // Parens

    ",", ";", ":", "::", "->", // Punctuation

    "=", // Operators

    "as", // Misc
} else {
    r"[a-zA-Z_][a-zA-Z0-9_]*" => IDENTIFIER,
    r"[-+]?[0-9]+" => INT_LITERAL,
} else {
    r"[-+]?[0-9]*\.?[0-9]+" => FLOAT_LITERAL,
    r"\s*" => { }, // Whitespace
}

pub Identifier: Identifier = IDENTIFIER => Identifier(<>.to_string());

pub Literal: Literal = {
    INT_LITERAL => Literal::Int(i32::from_str(<>).unwrap()),
    FLOAT_LITERAL => Literal::Float(f32::from_str(<>).unwrap()),
}

List<T, S>: Vec<T> = {
    <v:(<T> S)*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

#[inline]
Boxed<T>: Box<T> = T => Box::new(<>);
#[inline]
OptionBoxed<T>: OptionBox<T> = (Boxed<T>)?;

pub Module: Module = Item* => Module { items: <> };

pub Item: Item = {
    // <ImportItem> ";" => Item::Import(<>),
    FunctionItem => Item::Function(<>),
}

// pub ImportItem: ImportItem = "import" <ImportPath> => ImportItem(<>);

// pub ImportPath: ImportPath = {
//     ImportPathHead => ImportPath::Normal(<>),
//     "::" <ImportPathHead> => ImportPath::Special(SpecialScope::Root, <>),
//     <SpecialScope> "::" <ImportPathHead> => ImportPath::Special(<>),
// }

SpecialScope: SpecialScope = {
    "module" => SpecialScope::Module,
    "super" => SpecialScope::Super,
    "package" => SpecialScope::Package,
    "meta" => SpecialScope::Meta,
}

// ImportPathHead: ImportPathHead = {
//     Identifier => ImportPathHead::Final(<>),
//     Identifier ImportPathDelimiter ImportPathTail => ImportPathHead::Next(<>),
// }

// ImportPathDelimiter: ImportPathDelimiter = {
//     "::" => ImportPathDelimiter::Normal,
//     "->" => ImportPathDelimiter::Arrow,
// }

// ImportPathTail: ImportPathTail = {
//     Boxed<ImportPathHead> => ImportPathTail::Single(<>),
//     List<ImportPathHead, ","> => ImportPathTail::Multiple(<>),
// }

pub FunctionItem: FunctionItem =
    "func" <name: Identifier> <arguments: Arguments> <return_type: ("->" <Type>)?> <body: Block>
        => FunctionItem { <> };

pub Arguments: Vec<Argument> = "(" <List<Argument, ",">> ")";

pub Argument: Argument = <pattern: Pattern> ":" <declared_type: Type> => Argument { <> };

pub Type: Type = {
    <name: Identifier> => Type { <>, arguments: vec![] },
    <name: Identifier> "[" <arguments: List<Type, ",">> "]" => Type { <> },
}

pub Pattern: Pattern = {
    Identifier => Pattern::Identifier(<>),
}

pub Block: Block = {
    "{" "}" => Block { body: vec![], trailing: None },
    "{" <body: Statement*> <trailing: Boxed<Expression>> "}" => Block { body, trailing: Some(trailing) },
    "{" <body: Statement*> <last: LastStatement> "}" => Block {
        body: {
            let mut v = body;
            v.push(last);
            v
        },
        trailing: None
    },
}

pub Statement: Statement = {
    ExpressionWithBlock => Statement::SideEffect(<>),
    LastStatement,
}

#[inline]
LastStatement: Statement = {
    <ExpressionWithoutBlock> ";" => Statement::SideEffect(<>),
    "let" <Pattern> "=" <SplitExpression<";">> => Statement::Assignment(<>),
};

#[inline]
SplitExpression<T> = {
    <ExpressionWithBlock>,
    <ExpressionWithoutBlock> T,
}

pub Expression = {
    ExpressionWithBlock,
    ExpressionWithoutBlock,
}

ExpressionWithBlock: Expression = {
    Block => Expression::Block(<>),

    "return" <Boxed<ExpressionWithBlock>> => Expression::Return(Some(<>)),
    "break" <Boxed<ExpressionWithBlock>> => Expression::Break(Some(<>)),

    "match" <Boxed<ExpressionWithoutBlock>> "{" <MatchCase*> "}" => Expression::Match(<>),
    "if" <head: PartialIf> <tail: ("else" "if" <PartialIf>)*> <otherwise: ("else" <Block>)?>
        => Expression::If {
            otherwise,
            cases: {
                let mut tail = tail;
                tail.insert(0, head);
                tail
            }
        },

    "loop" <Block> => Expression::Loop(<>),
    "for" <pattern: Pattern> "in" <iterator: Boxed<ExpressionWithoutBlock>> <body: Block> <otherwise: ("else" <Block>)?>
        => Expression::For { <> },
    "while" <condition: Boxed<ConditionOrPattern>> <body: Block> <otherwise: ("else" <Block>)?>
        => Expression::While { <> },
}

#[inline]
MatchCase: MatchCase =
    <pattern: Pattern> <guard: ("if" <Expression>)?> "->" <result: SplitExpression<",">> => MatchCase { <> };

#[inline]
ConditionOrPattern: ConditionOrPattern = {
    ExpressionWithoutBlock => ConditionOrPattern::Condition(<>),
    "let" <Pattern> "=" <ExpressionWithoutBlock> => ConditionOrPattern::Pattern(<>),
}

#[inline]
PartialIf: PartialIf = ConditionOrPattern Block => PartialIf(<>);

ExpressionWithoutBlock: Expression = {
    "(" <Expression> ")",
    PathExpression => Expression::Lookup(<>),

    "return" <OptionBoxed<ExpressionWithoutBlock>> => Expression::Return(<>),
    "break" <OptionBoxed<ExpressionWithoutBlock>> => Expression::Break(<>),
    "continue" => Expression::Continue,

    <Boxed<CallTargetExpression>> "(" <List<Expression, ",">> ")" => Expression::Call(<>),
}

pub PathExpression: PathExpression = {
    Identifier => PathExpression::Identifier(<>),
    <Identifier> "::" <Boxed<PathExpressionTail>> => PathExpression::Path(PathExpressionTail::Next(<>)),
    "::" <PathExpressionTail> => PathExpression::Special(SpecialScope::Root, <>),
    <SpecialScope> "::" <PathExpressionTail> => PathExpression::Special(<>),
}

PathExpressionTail: PathExpressionTail = {
    Identifier => PathExpressionTail::Final(<>),
    <Identifier> "::" <Boxed<PathExpressionTail>> => PathExpressionTail::Next(<>),
}

CallTargetExpression: Expression = {
    PathExpression => Expression::Lookup(<>),
    "(" <Expression> ")",
}
