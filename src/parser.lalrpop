use crate::parse::*;

grammar;

match {
    r"\s*" => { }, // Whitespace
    r"//[^\n\r]*[\n\r]*" => { }, // `// comments`
    r"/\*([^\*]*\*+[^\*/])*([^\*]*\*+|[^\*])*\*/" => { },  // `/* comments */`
} else {
    "func",
    "let",
    "match", "if", "else",
    "loop",
    "for", "in",
    "while",
    "return", "break", "continue",
    "(", ")",
    "{", "}",
    "[", "]",
    ",", ";",
    ":", "->",
    "="
} else {
    r"[a-zA-Z_][a-zA-Z0-9_]*" => IDENTIFIER,
}

pub Identifier: Identifier = IDENTIFIER => Identifier(<>.to_string());

List<T, S>: Vec<T> = {
    <v:(<T> S)*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

#[inline]
Boxed<T>: Box<T> = T => Box::new(<>);
#[inline]
OptionBoxed<T>: OptionBox<T> = (Boxed<T>)?;

pub Module: Module = Item* => Module { items: <> };

pub Item: Item = {
    FunctionItem => Item::Function(<>),
}

pub FunctionItem: FunctionItem =
    "func" <name: Identifier> <arguments: Arguments> <return_type: ("->" <Type>)?> <body: Block>
        => FunctionItem { <> };

pub Arguments: Vec<Argument> = "(" <List<Argument, ",">> ")";

pub Argument: Argument = <pattern: Pattern> ":" <declared_type: Type> => Argument { <> };

pub Type: Type = {
    <name: Identifier> => Type { <>, arguments: vec![] },
    <name: Identifier> "[" <arguments: List<Type, ",">> "]" => Type { <> },
}

pub Pattern: Pattern = {
    Identifier => Pattern::Identifier(<>),
}

pub Block: Block = {
    "{" "}" => Block { body: vec![], trailing: None },
    "{" <body: Statement*> <trailing: Boxed<Expression>> "}" => Block { body, trailing: Some(trailing) },
    "{" <body: Statement*> <last: LastStatement> "}" => Block {
        body: {
            let mut v = body;
            v.push(last);
            v
        },
        trailing: None
    },
}

pub Statement: Statement = {
    ExpressionWithBlock => Statement::SideEffect(<>),
    LastStatement,
}

#[inline]
LastStatement: Statement = {
    <ExpressionWithoutBlock> ";" => Statement::SideEffect(<>),
    "let" <Pattern> "=" <SplitExpression<";">> => Statement::Assignment(<>),
};

#[inline]
SplitExpression<T> = {
    <ExpressionWithBlock>,
    <ExpressionWithoutBlock> T,
}

pub Expression = {
    ExpressionWithBlock,
    ExpressionWithoutBlock,
}

ExpressionWithBlock: Expression = {
    Block => Expression::Block(<>),

    "return" <Boxed<ExpressionWithBlock>> => Expression::Return(Some(<>)),
    "break" <Boxed<ExpressionWithBlock>> => Expression::Break(Some(<>)),

    "match" <Boxed<ExpressionWithoutBlock>> "{" <MatchCase*> "}" => Expression::Match(<>),
    "if" <head: PartialIf> <tail: ("else" "if" <PartialIf>)*> <otherwise: ("else" <Block>)?>
        => Expression::If {
            otherwise,
            cases: {
                let mut tail = tail;
                tail.insert(0, head);
                tail
            }
        },

    "loop" <Block> => Expression::Loop(<>),
    "for" <pattern: Pattern> "in" <iterator: Boxed<ExpressionWithoutBlock>> <body: Block> <otherwise: ("else" <Block>)?>
        => Expression::For { <> },
    "while" <condition: Boxed<ConditionOrPattern>> <body: Block> <otherwise: ("else" <Block>)?>
        => Expression::While { <> },
}

pub MatchCase: MatchCase =
    <pattern: Pattern> <guard: ("if" <Expression>)?> "->" <result: SplitExpression<",">> => MatchCase { <> };

#[inline]
ConditionOrPattern: ConditionOrPattern = {
    ExpressionWithoutBlock => ConditionOrPattern::Condition(<>),
    "let" <Pattern> "=" <ExpressionWithoutBlock> => ConditionOrPattern::Pattern(<>),
}

#[inline]
PartialIf: PartialIf = ConditionOrPattern Block => PartialIf(<>);

ExpressionWithoutBlock: Expression = {
    "(" <Expression> ")",

    "return" <OptionBoxed<ExpressionWithoutBlock>> => Expression::Return(<>),
    "break" <OptionBoxed<ExpressionWithoutBlock>> => Expression::Break(<>),

    "continue" => Expression::Continue,
    Identifier => Expression::Lookup(<>),
    <Boxed<CallTargetExpression>> "(" <List<Expression, ",">> ")" => Expression::Call(<>),
}

CallTargetExpression: Expression = {
    Identifier => Expression::Lookup(<>),
    "(" <Expression> ")",
}
