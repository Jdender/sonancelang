use crate::ast::structure::*;
use std::str::FromStr;

grammar;

match {
    "I32", // Temporary

    "func", "->", "let", ";", // Functions

    "=", "return", // Special Operators

    "(", ")", "{", "}", // Parens

    "+", "-", "*", "/", // Numeric Operators

    "==", "!=", "<", ">", "<=", ">=", // Comparison Operators

    "!", "||", "&&", // Boolean Operators

    r"[a-zA-Z_]\w*" => IDENTIFIER,
    r"[0-9]+" => INT_LITERAL,
}

#[inline]
Boxed<T>: Box<T> = T => Box::new(<>);

pub File: File =
    "func" <name: Identifier> "(" ")" "->" "I32" <body: Block> => File { <> };

pub Block: Block = "{" <Statement*> "}" => Block(<>);

pub Identifier: Identifier = IDENTIFIER => Identifier(<>.to_string());

pub Statement: Statement = {
    "let" <Identifier> "=" <Expression> ";" => Statement::LetBinding(<>),
    <Expression> ";" => Statement::Expression(<>),
    <ExpressionWithBlock> => Statement::Expression(<>),
}

pub ExpressionWithBlock: Expression = {
    Block => Expression::Block(<>),
}

pub Expression = {
    ExpressionWithBlock,
    "return" <Boxed<Expression>> => Expression::ReturnValue(<>),
    <Identifier> "=" <Boxed<Expression>> => Expression::Assignment(<>),
    ExprPre6,
}

ExprPreN<X, OP, Y>: Expression = {
    Boxed<X> OP Boxed<Y> => Expression::InfixCall(<>),
    Y,
}

ExprPre6 = ExprPreN<ExprPre6, OpPre6, ExprPre5>;

OpPre6: InfixOp = {
    "||" => InfixOp::BooleanOr,
}

ExprPre5 = ExprPreN<ExprPre5, OpPre5, ExprPre4>;

OpPre5: InfixOp = {
    "&&" => InfixOp::BooleanAnd,
}

ExprPre4 = ExprPreN<ExprPre4, OpPre4, ExprPre3>;

OpPre4: InfixOp = {
    "==" => InfixOp::Equal,
    "!="=> InfixOp::NotEqual,
}

ExprPre3 = ExprPreN<ExprPre3, OpPre3, ExprPre2>;

OpPre3: InfixOp = {
    ">"=> InfixOp::GreaterThan,
    "<"=> InfixOp::LessThan,
    ">="=> InfixOp::GreaterOrEqual,
    "<="=> InfixOp::LessOrEqual,
}

ExprPre2 = ExprPreN<ExprPre2, OpPre2, ExprPre1>;

OpPre2: InfixOp = {
    "+" => InfixOp::Add,
    "-" => InfixOp::Subtract,
}

ExprPre1 = ExprPreN<ExprPre1, OpPre1, ExprPre0>;

OpPre1: InfixOp = {
    "*" => InfixOp::Multiply,
    "/" => InfixOp::Divide,
}

ExprPre0: Expression = {
    PrefixOp Boxed<ExprPre0> => Expression::PrefixCall(<>),
    "(" <Expression> ")",

    IntLiteral => Expression::Literal(<>),
    Identifier => Expression::Lookup(<>),
}

PrefixOp: PrefixOp = {
    "-" => PrefixOp::Negate,
    "!" => PrefixOp::BooleanNot,
}

pub IntLiteral: i32 = INT_LITERAL => i32::from_str(<>).unwrap();
