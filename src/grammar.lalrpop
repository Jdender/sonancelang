use crate::ast::structure::*;
use std::str::FromStr;

grammar;

match {
    "I32", // Temporary

    "func", "->", "let", ";", // Functions

    "=", "return", "if", "else", // Special Operators

    "(", ")", "{", "}", // Parens

    "+", "-", "*", "/", // Numeric Operators

    "==", "!=", "<", ">", "<=", ">=", // Comparison Operators

    "!", "||", "&&", // Boolean Operators

    r"[a-zA-Z_]\w*" => IDENTIFIER,
    r"[0-9]+" => INT_LITERAL,
}

#[inline]
Boxed<T>: Box<T> = T => Box::new(<>);

pub File: File =
    "func" <name: Identifier> "(" ")" "->" "I32" <body: Block> => File { <> };

pub Block: Block = "{" <body: Statement*> <trailing: Boxed<Expression>> "}" => Block { <> };

pub Identifier: Identifier = IDENTIFIER => Identifier(<>.to_string());

pub Statement: Statement = {
    "let" <place: Identifier> "=" <operand: Expression> ";" => Statement::LetBinding { <> },
    <Expression> ";" => Statement::Expression(<>),
    <ExpressionWithBlock> => Statement::Expression(<>),
}

pub ExpressionWithBlock: Expression = {
    Block => Expression::Block(<>),
    "if" <predicate: Boxed<Expression>> <when_true: Block> "else" <when_false: Block> => Expression::Conditional {<>},
}

pub Expression = {
    ExpressionWithBlock,
    "return" <Boxed<Expression>> => Expression::ReturnValue(<>),
    <place: Identifier> "=" <operand: Boxed<Expression>> => Expression::Assignment { <> },
    ExprPre6,
}

ExprPreN<X, Op, Y>: Expression = {
    <x_operand: Boxed<X>> <operator: Op> <y_operand: Boxed<Y>> => Expression::InfixCall { <> },
    Y,
}

ExprPre6 = ExprPreN<ExprPre6, OpPre6, ExprPre5>;

OpPre6: InfixOperator = {
    "||" => InfixOperator::BooleanOr,
}

ExprPre5 = ExprPreN<ExprPre5, OpPre5, ExprPre4>;

OpPre5: InfixOperator = {
    "&&" => InfixOperator::BooleanAnd,
}

ExprPre4 = ExprPreN<ExprPre4, OpPre4, ExprPre3>;

OpPre4: InfixOperator = {
    "==" => InfixOperator::Equal,
    "!="=> InfixOperator::NotEqual,
}

ExprPre3 = ExprPreN<ExprPre3, OpPre3, ExprPre2>;

OpPre3: InfixOperator = {
    ">"=> InfixOperator::GreaterThan,
    "<"=> InfixOperator::LessThan,
    ">="=> InfixOperator::GreaterOrEqual,
    "<="=> InfixOperator::LessOrEqual,
}

ExprPre2 = ExprPreN<ExprPre2, OpPre2, ExprPre1>;

OpPre2: InfixOperator = {
    "+" => InfixOperator::Add,
    "-" => InfixOperator::Subtract,
}

ExprPre1 = ExprPreN<ExprPre1, OpPre1, ExprPre0>;

OpPre1: InfixOperator = {
    "*" => InfixOperator::Multiply,
    "/" => InfixOperator::Divide,
}

ExprPre0: Expression = {
    <operator: PrefixOperator> <operand: Boxed<ExprPre0>> => Expression::PrefixCall { <> },
    "(" <Expression> ")",

    IntLiteral => Expression::Literal(<>),
    Identifier => Expression::Lookup(<>),
}

PrefixOperator: PrefixOperator = {
    "-" => PrefixOperator::Negate,
    "!" => PrefixOperator::BooleanNot,
}

pub IntLiteral: i32 = INT_LITERAL => i32::from_str(<>).unwrap();
