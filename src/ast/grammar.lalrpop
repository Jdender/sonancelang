use std::str::FromStr;
use crate::ast::*;

grammar;

match {
    "export", "func",  // Item

    ":", "->", ";", // Punctuation

    "I32", "F32", // Tys

    "let", "if", "else", "=", // Special Operators

    "(", ")", "{", "}", // Parens

    "+", "-", "*", "/", // Numeric Operators

    "==", "!=", "<", ">", "<=", ">=", // Comparison Operators

    "!", "||", "&&", // Boolean Operators

    // Regex Tokens
    r"[a-zA-Z_]\w*" => IDENTIFIER,
    r"[+-]?\d+" => INT_LITERAL,
    r"[+-]?\d+\.\d+" => FLOAT_LITERAL,
}

#[inline]
Boxed<T>: Box<T> = T => Box::new(<>);

pub File: File = <scope: Scope> "func" <name: Identifier>  "(" ")" "->" <ty: Ty> <body: Block> => File { <> };

Scope: Scope = {
    => Scope::Local,
    "export" => Scope::Export,
}

Identifier: Identifier = IDENTIFIER => Identifier::new(<>.to_string());

Ty: Ty = {
    "I32" => Ty::I32,
    "F32" => Ty::F32,
}

Block: Block = "{" <body: Statement*> <trailing: Boxed<Expression>> "}" => Block { <> };

Statement: Statement = {
    "let" <place: Identifier> <ty: (":" <Ty>)?> "=" <value: Expression> ";" => Statement::LetBinding { <> },
    <Expression> ";" => Statement::SideEffect(<>),
    <ExpressionWithBlock> => Statement::SideEffect(<>),
}

ExpressionWithBlock: Expression = {
    Block => Expression::Block(<>),
    "if" <predicate: Boxed<Expression>> <when_true: Block> "else" <when_false: Block> => Expression::IfElse { <> },
}

Expression = {
    <place: Identifier> "=" <value: Boxed<Expression>> => Expression::Assignment { <> },
    ExpressionWithBlock,
    ExprPre6,
}

ExprPreN<X, Op, Y>: Expression = {
    <left: Boxed<X>> <operator: Op> <right: Boxed<Y>> => Expression::InfixCall { <> },
    Y,
}

ExprPre6 = ExprPreN<ExprPre6, OpPre6, ExprPre5>;

OpPre6: InfixOperator = {
    // "||" => InfixOperator::BooleanOr,
}

ExprPre5 = ExprPreN<ExprPre5, OpPre5, ExprPre4>;

OpPre5: InfixOperator = {
    // "&&" => InfixOperator::BooleanAnd,
}

ExprPre4 = ExprPreN<ExprPre4, OpPre4, ExprPre3>;

OpPre4: InfixOperator = {
    "==" => InfixOperator::Equal,
    "!="=> InfixOperator::NotEqual,
}

ExprPre3 = ExprPreN<ExprPre3, OpPre3, ExprPre2>;

OpPre3: InfixOperator = {
    ">"=> InfixOperator::GreaterThan,
    "<"=> InfixOperator::LessThan,
    ">="=> InfixOperator::GreaterOrEqual,
    "<="=> InfixOperator::LessOrEqual,
}

ExprPre2 = ExprPreN<ExprPre2, OpPre2, ExprPre1>;

OpPre2: InfixOperator = {
    "+" => InfixOperator::Add,
    "-" => InfixOperator::Subtract,
}

ExprPre1 = ExprPreN<ExprPre1, OpPre1, ExprPre0>;

OpPre1: InfixOperator = {
    "*" => InfixOperator::Multiply,
    "/" => InfixOperator::Divide,
}

ExprPre0: Expression = {
    <operator: PrefixOperator> <value: Boxed<ExprPre0>> => Expression::PrefixCall { <> },
    "(" <Expression> ")",

    Literal => Expression::Literal(<>),
    Identifier => Expression::Lookup(<>),
}

PrefixOperator: PrefixOperator = {
    "-" => PrefixOperator::Negate,
    // "!" => PrefixOperator::BooleanNot,
}

Literal: Literal = {
    INT_LITERAL => Literal::I32(i32::from_str(<>).unwrap()),
    FLOAT_LITERAL => Literal::F32(f32::from_str(<>).unwrap()),
}
