import sonance -> mem::{swap, size_of, RawPointer, Glob};

export struct Array [type T, const LENGTH: USize] {
    // A poitner to a binary glob the size of (size of `T` multiplied by `LENGTH`)
    pointer: RawPointer[Glob[size_of[T] * LENGTH]],
}

impl[type T, const LENGTH: USize] Array[T, LENGTH] {

    /**
        -> The length of the Array
    */
    export func length() -> USize {
        LENGTH
    }

    /**
        index: Position in `Array` to get from
        -> A reference to the value if found, or `None` if out of bounds
    */
    export func get(&self, index: USize) -> Option[&T] {
        if index >= LENGTH { // Bounds check
            //  `None` variant of Option, represents nothing
            None
        } else {
            // `Some` variant of Option, it takes one value T
            Some(unsafe { // Raw pointers can only be dereferenced in marked areas
                self.pointer
                    .offset(size_of[T] * index) // Find where in the array
                    .promote['self] // Assert to compiler pointer lasts as long as self
            })
        }
    }

    /**
        index: Index to set the new value to
        value: The new value
        -> The previous value, or `None` if out of bounds
    */
    export func set(&mut self, index: USize, value: T) -> Option[T] {
        if index >= LENGTH {
            None
        } else {
            // Raw pointers can only be dereferenced in marked areas
            Some(unsafe {
                self.pointer
                    .offset(size_of[T] * index)
                    .swap(value)
            })
        }
    }
}
