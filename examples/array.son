import {
    sonance::mem::{ swap, size_of, RawPointer, Glob },
}

export struct Array[type T, const LENGTH: USize] {
    // A pointer to a binary glob the size of (size of `T` multiplied by `LENGTH`)
    pointer: RawPointer[type BinaryGlob[const size_of[T] * LENGTH]],
}

impl[type T, const LENGTH: USize] Array[type T, const LENGTH] {

    /**
        -> The length of the Array
    */
    export func length() -> USize {
        LENGTH
    }

    /**
        index: Position in `Array` to get from
        -> A reference to the value if found, or `None` if out of bounds
    */
    export func get(self: &Self, index: USize) -> Option[type &T] {
        if index >= LENGTH { // Bounds check
            //  `None` variant of Option, represents nothing
            None
        } else {
            // `Some` variant of Option, it takes one value T
            Some { unsafe {
                // Raw pointers can only be dereferenced in marked areas
                let ptr = self.pointer.offset(size_of[type T] * index); // Find where in the array
                &'self *ptr // Assert to compiler pointer lives as long as self
            }}
        }
    }

    /**
        index: Index to set the new value to
        value: The new value
        -> The previous value, or `None` if out of bounds
    */
    export func set(self: &mut Self, index: USize, value: T) -> Option[type T] {
        if index >= LENGTH {
            None
        } else {
            // Raw pointers can only be dereferenced in marked areas
            Some { unsafe {
                self.pointer
                    .offset(size_of[type T] * index)
                    .swap(value)
            }}
        }
    }
}
